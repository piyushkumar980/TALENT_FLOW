// src/api/msw/handlers.js
import { http as mswHttp, HttpResponse as mswResponse } from "msw";
import { db as localDb, rid as randomId } from "../../lib/db.js";

/* SMALL HELPERS */

// NORMALIZE A POSITIVE INTEGER OR FALL BACK TO A DEFAULT
const toPositiveIntOr = (value, fallback) => {
  const num = Number(value);
  return Number.isFinite(num) && num > 0 ? num : fallback;
};

// MAKE A URL-FRIENDLY SLUG
const toSlug = (input = "") =>
  String(input)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^[-]+|[-]+$/g, "");

// ENSURE A SLUG IS UNIQUE ACROSS THE JOBS TABLE BY APPENDING A COUNTER
async function ensureUniqueJobSlug(base = "job") {
  const seed = base || "job";
  let candidate = seed;
  let i = 1;
  // KEEP INCREMENTING UNTIL NO MATCH IS FOUND
  // NOTE: DEXIE WHERE-CLAUSE LOOKUP IS ASYNC
  while (await localDb.jobs.where("slug").equals(candidate).first()) {
    candidate = `${seed}-${i++}`;
  }
  return candidate;
}

// RETURN A PAGINATED SHALLOW COPY FROM AN ARRAY
const paginateArray = (rows, page = 1, pageSize = 20) => {
  const start = (page - 1) * pageSize;
  return {
    page,
    pageSize,
    total: rows.length,
    items: rows.slice(start, start + pageSize),
  };
};

// STAGE ENUM FOR CANDIDATES
const PIPELINE_STAGES = [
  "applied",
  "screen",
  "tech",
  "offer",
  "hired",
  "rejected",
];
const isKnownStage = (value) =>
  PIPELINE_STAGES.includes(String(value || "").toLowerCase());

/* LIGHTWEIGHT QUESTION BANK */

// TOPIC LIST FOR AUTOGENERATED ASSESSMENTS
const QUESTION_TOPICS = [
  "html",
  "css",
  "javascript",
  "react",
  "node",
  "express",
  "mongo",
  "java",
  "c",
  "cpp",
  "sql",
  "python",
];

// BUILD A SINGLE MULTIPLE-CHOICE QUESTION FOR A TOPIC
function createSingleChoiceQuestion(topic, index) {
  const id = `${topic}-${index + 1}`;
  const TOPIC = topic.toUpperCase();
  const label = `[${TOPIC}] Q${index + 1}: Basic concept ${
    index + 1
  } for ${TOPIC}?`;
  const options = [
    `${TOPIC} Option A`,
    `${TOPIC} Option B`,
    `${TOPIC} Option C`,
    `${TOPIC} Option D`,
  ];
  const answer = index % 4; // INDEX OF CORRECT OPTION (0..3)
  return { id, type: "single", label, options, answer };
}

// CREATE A COMPLETE BANK FOR EACH TOPIC (24 QUESTIONS/TOPIC)
function buildQuestionBank() {
  const bank = {};
  for (const topic of QUESTION_TOPICS) {
    bank[topic] = Array.from({ length: 24 }, (_, i) =>
      createSingleChoiceQuestion(topic, i)
    );
  }
  return bank;
}

// SHUFFLE ALL QUESTIONS AND PICK A MIXED SET OF 20
function pickTwentyMixedQuestions(bank) {
  const combined = [];
  for (const topic of QUESTION_TOPICS) combined.push(...(bank[topic] || []));
  for (let i = combined.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [combined[i], combined[j]] = [combined[j], combined[i]];
  }
  return combined.slice(0, 20);
}

/* JOBS */

// GET /jobs?search=&status=&page=&pageSize=&sort=
// RETURNS A FILTERED, SORTED, PAGINATED LIST OF JOBS
const getJobs = mswHttp.get("/jobs", async ({ request }) => {
  const url = new URL(request.url);
  const searchNeedle = (url.searchParams.get("search") || "")
    .toLowerCase()
    .trim();
  const statusFilter = (url.searchParams.get("status") || "").trim();
  const page = toPositiveIntOr(url.searchParams.get("page"), 1);
  const pageSize = toPositiveIntOr(url.searchParams.get("pageSize"), 20);
  const sortKey = url.searchParams.get("sort") || "order";

  let rows = await localDb.jobs.toArray();

  // APPLY TEXT SEARCH ACROSS COMMON FIELDS
  if (searchNeedle) {
    rows = rows.filter((j) => {
      const title = (j.title || "").toLowerCase();
      const company = (j.company || "").toLowerCase();
      const role = (j.role || "").toLowerCase();
      const slug = (j.slug || "").toLowerCase();
      return (
        title.includes(searchNeedle) ||
        company.includes(searchNeedle) ||
        role.includes(searchNeedle) ||
        slug.includes(searchNeedle)
      );
    });
  }

  // OPTIONAL STATUS FILTER
  if (statusFilter) rows = rows.filter((j) => j.status === statusFilter);

  // STABLE SORTS FOR UX PREDICTABILITY
  if (sortKey === "title")
    rows.sort((a, b) => (a.title || "").localeCompare(b.title || ""));
  else if (sortKey === "status")
    rows.sort((a, b) => (a.status || "").localeCompare(b.status || ""));
  else rows.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

  return mswResponse.json(paginateArray(rows, page, pageSize));
});

// GET /jobs/:id
// RETURNS A SINGLE JOB ROW OR 404
const getJobById = mswHttp.get("/jobs/:id", async ({ params }) => {
  const id = Number(params.id);
  const job = await localDb.jobs.get(id);
  if (!job) {
    return mswResponse.json({ message: "Job not found" }, { status: 404 });
  }
  return mswResponse.json(job);
});

// POST /jobs
// CREATES A NEW JOB WITH A UNIQUE SLUG AND DEFAULT ORDER
const postJob = mswHttp.post("/jobs", async ({ request }) => {
  const body = (await request.json().catch(() => ({}))) || {};
  const title = (body.title || "Untitled").trim();

  // DERIVE A BASE SLUG FROM EITHER INPUT OR TITLE, THEN ENSURE UNIQUENESS
  let slug = body.slug ? toSlug(body.slug) : toSlug(title);
  slug = await ensureUniqueJobSlug(slug);

  // ONLY TWO ALLOWED STATUSES; DEFAULT TO "active"
  const status = body.status === "archived" ? "archived" : "active";

  // ACCEPT ARRAY OR COMMA-SEPARATED STRING FOR TAGS
  const tags = Array.isArray(body.tags)
    ? body.tags.map(String)
    : String(body.tags || "")
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean);

  // PLACE NEW JOB AT THE END OF THE CURRENT ORDER
  const order = await localDb.jobs.count();

  const rowToSave = { title, slug, status, tags, order };
  const id = await localDb.jobs.add(rowToSave);

  return mswResponse.json({ id, ...rowToSave }, { status: 201 });
});

// PATCH /jobs/:id
// UPDATES ALLOWED FIELDS; COERCE AND DEDUPE SLUGS; NORMALIZE TAGS
const patchJob = mswHttp.patch("/jobs/:id", async ({ params, request }) => {
  const id = Number(params.id);
  const body = (await request.json().catch(() => ({}))) || {};
  const allowedKeys = ["title", "slug", "status", "tags"];

  // STRIP UNKNOWN KEYS
  const patch = Object.fromEntries(
    Object.entries(body).filter(([k]) => allowedKeys.includes(k))
  );

  // SLUG SANITIZATION + UNIQUENESS CHECK
  if (patch.slug) {
    patch.slug = toSlug(patch.slug);
    const conflict = await localDb.jobs
      .where("slug")
      .equals(patch.slug)
      .first();
    if (conflict && conflict.id !== id)
      patch.slug = await ensureUniqueJobSlug(patch.slug);
  }

  // STATUS NORMALIZATION
  if (patch.status) {
    const s = String(patch.status).toLowerCase();
    if (s === "active" || s === "archived") patch.status = s;
    else delete patch.status;
  }

  // TAG INPUT FLEXIBILITY (ARRAY OR CSV)
  if (patch.tags && !Array.isArray(patch.tags)) {
    patch.tags = String(patch.tags)
      .split(",")
      .map((t) => t.trim())
      .filter(Boolean);
  }

  await localDb.jobs.update(id, patch);
  const updated = await localDb.jobs.get(id);
  if (!updated)
    return mswResponse.json({ message: "Job not found" }, { status: 404 });
  return mswResponse.json(updated);
});

// PATCH /jobs/:id/reorder
// MOVES A JOB FROM ONE ORDER INDEX TO ANOTHER; RANDOMLY FAILS TO SIMULATE FLakE
const patchReorder = mswHttp.patch("/jobs/:id/reorder", async ({ request }) => {
  // CHAOS MONKEY: INTRODUCE A SMALL CHANCE OF FAILURE TO TEST RETRIES
  if (Math.random() < 0.2) {
    return mswResponse.json(
      { message: "Random reorder failure" },
      { status: 500 }
    );
  }

  const body = (await request.json().catch(() => ({}))) || {};
  const fromOrder = Number(body.fromOrder);
  const toOrder = Number(body.toOrder);

  const list = await localDb.jobs.orderBy("order").toArray();
  const fromIdx = list.findIndex((j) => j.order === fromOrder);
  const toIdx = list.findIndex((j) => j.order === toOrder);

  if (fromIdx < 0 || toIdx < 0) {
    return mswResponse.json({ message: "Invalid indices" }, { status: 400 });
  }

  const [moved] = list.splice(fromIdx, 1);
  list.splice(toIdx, 0, moved);

  // REWRITE SEQUENTIAL ORDER VALUES AFTER REARRANGE
  await Promise.all(
    list.map((j, i) => localDb.jobs.update(j.id, { order: i }))
  );

  return mswResponse.json({ fromOrder, toOrder, ok: true });
});

/* CANDIDATES */

// GET /candidates?search=&stage=&page=&pageSize=
// RETURNS PAGINATED CANDIDATE LIST WITH OPTIONAL TEXT/STAGE FILTERS
const getCandidates = mswHttp.get("/candidates", async ({ request }) => {
  const url = new URL(request.url);
  const searchNeedle = (url.searchParams.get("search") || "")
    .toLowerCase()
    .trim();
  const stageFilter = (url.searchParams.get("stage") || "")
    .toLowerCase()
    .trim();
  const page = toPositiveIntOr(url.searchParams.get("page"), 1);
  const pageSize = toPositiveIntOr(url.searchParams.get("pageSize"), 50);

  let rows = await localDb.candidates.toArray();

  if (searchNeedle) {
    rows = rows.filter(
      (c) =>
        (c.name || "").toLowerCase().includes(searchNeedle) ||
        (c.email || "").toLowerCase().includes(searchNeedle)
    );
  }

  if (stageFilter && isKnownStage(stageFilter)) {
    rows = rows.filter((c) => String(c.stage).toLowerCase() === stageFilter);
  }

  // SORT ALPHABETICALLY FOR A STABLE UI
  rows.sort((a, b) => (a.name || "").localeCompare(b.name || ""));

  return mswResponse.json(paginateArray(rows, page, pageSize));
});

// GET /candidates/:id
// RETURNS A SINGLE CANDIDATE OR AN ERROR
const getCandidateById = mswHttp.get("/candidates/:id", async ({ params }) => {
  const id = Number(params.id);
  if (!Number.isFinite(id)) {
    return mswResponse.json(
      { message: "Invalid candidate id" },
      { status: 400 }
    );
  }
  const cand = await localDb.candidates.get(id);
  if (!cand) {
    return mswResponse.json(
      { message: "Candidate not found" },
      { status: 404 }
    );
  }
  return mswResponse.json(cand);
});

// POST /candidates
// CREATES A NEW CANDIDATE AND LOGS AN INITIAL TIMELINE ENTRY
const postCandidate = mswHttp.post("/candidates", async ({ request }) => {
  const body = (await request.json().catch(() => ({}))) || {};

  // NAME + EMAIL WITH SANE DEFAULTS
  const name = (body.name || "New Candidate").trim();
  const email = (body.email || `user-${randomId()}@mail.com`)
    .trim()
    .toLowerCase();

  // VALIDATE AND NORMALIZE STAGE
  const normalizedStage = isKnownStage(body.stage)
    ? String(body.stage).toLowerCase()
    : "applied";

  // IF JOB ID IS MISSING, PICK A RANDOM ONE FROM EXISTING JOBS
  let jobId = Number(body.jobId);
  if (!Number.isFinite(jobId)) {
    const jobIds = await localDb.jobs.toCollection().primaryKeys();
    jobId = jobIds.length
      ? jobIds[Math.floor(Math.random() * jobIds.length)]
      : undefined;
  }

  // BASIC PROFILE WITH PLACEHOLDERS
  const newCandidateRow = {
    name,
    email,
    stage: normalizedStage,
    jobId,
    phone:
      body.phone ||
      `(${100 + Math.floor(Math.random() * 800)}) ${
        100 + Math.floor(Math.random() * 900)
      }-${1000 + Math.floor(Math.random() * 9000)}`,
    location: body.location || "Remote",
    position: body.position || "Applicant",
    experience: body.experience || `${1 + Math.floor(Math.random() * 9)} years`,
    skills: body.skills || ["Communication", "Teamwork"],
    education: body.education || "BS (any)",
    status: body.status || "New",
    lastContact: body.lastContact || "Today",
    notes: body.notes || "—",
  };

  const id = await localDb.candidates.add(newCandidateRow);

  // APPEND A TIMELINE ENTRY FOR THE INITIAL STAGE
  await localDb.timelines.add({
    candidateId: id,
    stage: normalizedStage,
    ts: Date.now(),
    by: "System",
    note: `Stage set to ${normalizedStage}`,
  });

  return mswResponse.json({ id, ...newCandidateRow }, { status: 201 });
});

// PATCH /candidates/:id
// UPDATES CANDIDATE FIELDS; IF STAGE CHANGES, LOG IT TO THE TIMELINE
const patchCandidate = mswHttp.patch(
  "/candidates/:id",
  async ({ params, request }) => {
    const id = Number(params.id);
    const body = (await request.json().catch(() => ({}))) || {};

    const existing = await localDb.candidates.get(id);
    if (!existing)
      return mswResponse.json(
        { message: "Candidate not found" },
        { status: 404 }
      );

    const patch = { ...body };

    // HANDLE STAGE CHANGE WITH AUDIT TRAIL
    if (patch.stage) {
      const nextStage = String(patch.stage).toLowerCase();
      const prevStage = String(existing.stage).toLowerCase();
      if (isKnownStage(nextStage) && nextStage !== prevStage) {
        await localDb.timelines.add({
          candidateId: id,
          stage: nextStage,
          ts: Date.now(),
          by: body.by || "System",
          note: body.note || `Stage set to ${nextStage}`,
        });
        patch.stage = nextStage;
      } else {
        // DROP INVALID OR NO-OP STAGE CHANGES
        delete patch.stage;
      }
    }

    await localDb.candidates.update(id, patch);
    const updated = await localDb.candidates.get(id);
    return mswResponse.json(updated);
  }
);

// GET /candidates/:id/timeline
// RETURNS THE CANDIDATE'S TIMELINE IN CHRONOLOGICAL ORDER
const getCandidateTimeline = mswHttp.get(
  "/candidates/:id/timeline",
  async ({ params }) => {
    const id = Number(params.id);
    if (!Number.isFinite(id)) {
      return mswResponse.json(
        { message: "Invalid candidate id" },
        { status: 400 }
      );
    }
    const items = await localDb.timelines
      .where("candidateId")
      .equals(id)
      .toArray();
    items.sort((a, b) => a.ts - b.ts);
    return mswResponse.json({ candidateId: id, items });
  }
);

/* ASSESSMENTS*/

// GET /assessments/:jobId
// RETURNS A 20-QUESTION MIXED ASSESSMENT; BUILDS/REBUILDS IF NEEDED
const getAssessment = mswHttp.get("/assessments/:jobId", async ({ params }) => {
  const jobId = Number(params.jobId);

  const saved = await localDb.assessments.get(jobId);
  if (saved && Array.isArray(saved.sections) && saved.sections.length > 0) {
    const firstSection = saved.sections[0] || {
      title: "Mixed Assessment",
      questions: [],
    };
    if ((firstSection.questions || []).length !== 20) {
      const bank = buildQuestionBank();
      const mixed = pickTwentyMixedQuestions(bank);
      const doc = {
        jobId,
        sections: [{ title: "Mixed Assessment", questions: mixed }],
      };
      await localDb.assessments.put(doc);
      return mswResponse.json(doc);
    }
    return mswResponse.json(saved);
  }

  // FIRST-TIME GENERATION
  const bank = buildQuestionBank();
  const mixed = pickTwentyMixedQuestions(bank);
  const doc = {
    jobId,
    sections: [{ title: "Mixed Assessment", questions: mixed }],
  };
  await localDb.assessments.put(doc);
  return mswResponse.json(doc);
});

// PUT /assessments/:jobId
// OVERWRITES THE ASSESSMENT DOCUMENT; ENFORCES MAX OF 20 QUESTIONS IN FIRST SECTION
const putAssessment = mswHttp.put(
  "/assessments/:jobId",
  async ({ params, request }) => {
    const jobId = Number(params.jobId);
    const body = (await request.json().catch(() => ({}))) || {};
    const doc = { jobId, ...(body || {}) };

    if (
      Array.isArray(doc.sections) &&
      doc.sections[0]?.questions?.length > 20
    ) {
      doc.sections[0].questions = doc.sections[0].questions.slice(0, 20);
    }

    await localDb.assessments.put(doc);
    return mswResponse.json(doc);
  }
);

// POST /assessments/:jobId/submit
// STORES A LIGHTWEIGHT SUBMISSION RECORD WITH A TIMESTAMP
const postSubmission = mswHttp.post(
  "/assessments/:jobId/submit",
  async ({ params, request }) => {
    const jobId = Number(params.jobId);
    const body = (await request.json().catch(() => ({}))) || {};
    const record = {
      jobId,
      candidateId: Number(body.candidateId) || undefined,
      submittedAt: Date.now(),
      data: body.data ?? body,
    };
    const id = await localDb.submissions.add(record);
    return mswResponse.json({ id, ok: true });
  }
);

/*  EXPORT LIST */

// THE ORDER HERE DOESN'T CHANGE PUBLIC BEHAVIOR BUT IS GROUPED FOR READABILITY
export const handlers = [
  // JOBS
  getJobs,
  getJobById,
  postJob,
  patchJob,
  patchReorder,

  // CANDIDATES
  getCandidates,
  getCandidateById,
  postCandidate,
  patchCandidate,
  getCandidateTimeline,

  // ASSESSMENTS
  getAssessment,
  putAssessment,
  postSubmission,
];
